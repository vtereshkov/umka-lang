// Raytracer demo in Umka

import (
    "std.um"
    "mat.um"
)

fn randn(): mat.Vec {
    return {std.frand() - 0.5, std.frand() - 0.5, std.frand() - 0.5}
}

type Color = mat.Vec

type Ray = struct {
    origin, dir: mat.Vec
}

type GenericBody = struct {
    center:      mat.Vec
    color:       Color
    diffuseness: real
    isLamp:      bool
}

fn (b: ^GenericBody) lambertFactor(lambert: real): real {
    return 1.0 - (1.0 - lambert) * b.diffuseness
}

type Body = interface {
    get(): ^GenericBody
    intersect(ray: ^Ray, point, normal: ^mat.Vec): bool
}

type Box = struct {
    body: GenericBody
    halfsize: mat.Vec
}

fn (b: ^Box) get(): ^GenericBody {return &b.body}

fn (b: ^Box) intersectFace(ray: ^Ray, point, normal: ^mat.Vec, i, j, k: int): bool {
    if fabs(ray.dir[k]) > 1e-9 {
        side := 1.0
        if ray.dir[k] > 0.0 {
            side = -1.0
        }

        if factor := (b.body.center[k] + side * b.halfsize[k] - ray.origin[k]) / ray.dir[k]; factor > 0.1 {
            point^ = ray.origin.add(ray.dir.mul(factor))
            
            const within = fn (x, y, xmin, ymin, xmax, ymax: real): bool {
                               return (x > xmin) && (x < xmax) && (y > ymin) && (y < ymax)
                           }
            
            if within(
                point[i], point[j],
                b.body.center[i] - b.halfsize[i], b.body.center[j] - b.halfsize[j],
                b.body.center[i] + b.halfsize[i], b.body.center[j] + b.halfsize[j]) {

                normal[i] = 0
                normal[j] = 0
                normal[k] = side
                return true
            }
        }
    }
    return false
}

fn (b: ^Box) intersect(ray: ^Ray, point, normal: ^mat.Vec): bool {
    return b.intersectFace(ray, point, normal, 0, 1, 2) || 
           b.intersectFace(ray, point, normal, 2, 0, 1) || 
           b.intersectFace(ray, point, normal, 1, 2, 0)
}

type Sphere = struct {
    body: GenericBody
    radius: real
}

fn (s: ^Sphere) get(): ^GenericBody {return &s.body}

fn (s: ^Sphere) intersect(ray: ^Ray, point, normal: ^mat.Vec): bool {
    displacement := s.body.center.sub(ray.origin)
    proj := displacement.dot(ray.dir)
    discr := s.radius * s.radius + proj * proj - displacement.dot(displacement)

    if discr > 0 {        
        if factor := proj - sqrt(discr); factor > 0.1 {
            point^ = ray.origin.add(ray.dir.mul(factor))
            normal^ = point.sub(s.body.center).mul(1.0 / s.radius)
            return true
        }
    }
    return false
}

type Scene = struct {
    ambientColor: Color
    body:         []Body
}

fn (sc: ^Scene) trace(ray: ^Ray, depth: int): Color {
    if depth > 3 {
        return sc.ambientColor
    }

    // Find nearest intersection
    bestDist := 1e9
    bestIndex := -1
    var bestPoint, bestNormal: mat.Vec

    for i, b in sc.body {
        var point, normal: mat.Vec
        
        if found := b.intersect(ray, &point, &normal); found {           
            if dist := point.sub(ray.origin).norm(); dist < bestDist {
                bestDist = dist
                bestIndex = i
                bestPoint = point
                bestNormal = normal
            }
        }
    }

    // Reflect rays
    if bestIndex >= 0 {
        bestBody := sc.body[bestIndex].get()

        if bestBody.isLamp {
            return bestBody.color
        }

        specularDir := ray.dir.sub(bestNormal.mul(2.0 * (ray.dir.dot(bestNormal))))
        diffuseDir := specularDir.add(randn().mul(2.0 * bestBody.diffuseness)).normalize()

        lambert := diffuseDir.dot(bestNormal)
        if lambert < 0 {
            diffuseDir = diffuseDir.sub(bestNormal.mul(2.0 * lambert))
            lambert = -lambert
        }

        diffuseRay := Ray{bestPoint, diffuseDir}

        return Color(mat.Vec(sc.trace(&diffuseRay, depth + 1)).mul(bestBody.lambertFactor(lambert)).elementwise(mat.Vec(bestBody.color)))
    }

    return sc.ambientColor
}

const (width = 640; height = 480)

type (
    Pixels = [height][width][3]uint8

    RenderData = struct {
        startHeight:  int
        stopHeight:   int
        pos:          mat.Vec
        azimuth:      real
        focal:        real
        antialiasing: real
        numRays:      int
        scene:        ^Scene
        pixels:       ^Pixels
    }
)

fn render(parent: fiber, buf: ^RenderData) {
    sinAz, cosAz := sin(buf.azimuth), cos(buf.azimuth)
    
    for i := buf.startHeight; i < buf.stopHeight; i++ {
        for j := 0; j < width; j++ {
            dir := mat.Vec{j - width / 2, i - height / 2, buf.focal}

            rotDir := mat.Vec{
                 dir[0]*cosAz + dir[2]*sinAz,
                 dir[1],
                -dir[0]*sinAz + dir[2]*cosAz}

            color := Color{0, 0, 0}

            for r := 0; r < buf.numRays; r++ {
                randomDir := rotDir.add(randn().mul(buf.antialiasing))
                ray := Ray{buf.pos, randomDir.normalize()}
                color = Color(mat.Vec(color).add(mat.Vec(buf.scene.trace(&ray, 0))))
            }
            color = Color(mat.Vec(color).mul(255.0 / buf.numRays))
            
            buf.pixels[i][j] = {round(color[0]), round(color[1]), round(color[2])}
        }
        printf("%3lld/%3lld\n", i + 1, height)
        fibercall(parent)
    }
}

fn main() {
    // Define scene  
    body := []Body {
        Box {
            body: {
                center: {500, -100, 1200},
                color: {0.4, 0.7, 1.0},
                diffuseness: 0.1,
                isLamp: false
            },
            halfsize: {400 / 2.0, 600 / 2.0, 300 / 2.0}
        },
            
        Box {
            body: {
                center: {550, 210, 1100},
                color: {0.9, 1.0, 0.6},
                diffuseness: 0.3,
                isLamp: false
            },
            halfsize: {1000 / 2.0, 20 / 2.0, 1000 / 2.0}
        },            

        Sphere {
            body: {
                center: {600, 0, 700},
                color: {1.0, 0.4, 0.6},
                diffuseness: 0.2,
                isLamp: false
            },
            radius: 200
        },
            
        Sphere {
            body: {
                center: {330, 150, 700},
                color: {1.0, 1.0, 0.3},
                diffuseness: 0.15,
                isLamp: false
            },
            radius: 50
        },
            
        // Define light
        Sphere {
            body: {
                center: {500, -1000, -700},
                color: {1.0, 1.0, 1.0},
                diffuseness: 1.0,
                isLamp: true
            },
            radius: 800
        }
    }
            
    scene := &Scene{{0.2, 0.2, 0.2}, body}
    
    pixels := new(Pixels)            

    var numRays, numRenderers: int
    printf("Raytracer demo\n")
    printf("Rays per pixel (recommended 1 to 20): ");  scanf("%lld", &numRays)
    printf("Threads (recommended 1, 2, 4, 8, 16): ");  scanf("%lld", &numRenderers)
    
    // Define fibers
    renderers := make([]fiber, numRenderers)

    for i, renderer^ in renderers {
        // Define eye
        renderData := &RenderData{
            startHeight:  height / numRenderers * i,
            stopHeight:   height / numRenderers * (i + 1),
            pos:          {0, 0, 0},
            azimuth:      30.0 * std.pi / 180.0,
            focal:        500,
            antialiasing: 1.0,
            numRays:      numRays,
            scene:        scene,
            pixels:       pixels
        }
        
        // Spawn fiber
        renderer^ = fiberspawn(render, renderData)
    }  

    // Render scene
    startTime := std.clock()
    
    for true {
        working := false
        for _, renderer in renderers {
            if fiberalive(renderer) { 
                fibercall(renderer)
                working = true
            }
        }
        if !working {break}
    }    
        
    endTime := std.clock()    
    printf("Rendering time = %.3f s\n", endTime - startTime)
    
    // Write output file
    const fileName = "scene.ppm"
    f, err := std.fopen(fileName, "wb")
    std.exitif(err)
    fprintf(f, "P6\n%lld %lld\n255\n", width, height)
    std.fwrite(f, pixels)
    std.fclose(f)
    std.println("Done. See " + fileName)
    std.getchar()
    std.getchar()
}
