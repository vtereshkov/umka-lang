
type (
	Rune = int32								
)

fn (r: ^Rune) size*(): int {
	if r^ < 0x7f {
		return 1
	}

	if r^ < 0x7ff {
		return 2
	}

	if r^ < 0xffff {
		return 3
	}

	if r^ < 0x10ffff {
		return 4
	}

	return 0
}

fn printBin(n: int32, count: int) {
	for i:=0; i < count; i++ {
		printf("%d ", n & 1)
		n = n >> 1
	}
}

fn (r: ^Rune) encode*(): str {
	s := r.size()

	if s == 1 {
		return str(char(r^))
	}

	out := make([]char, s + 1)

	// header is size amount of ones at the start
	header := 0
	for i:=0; i < s + 1; i++ {
		header |= 1 << (8 - i)
	}

	shift := (s - 1) * 6
	out[0] = char(((r^ >> shift & 0xff) | header) & 0xff)

	// following headers are only 1
	header = 1 << 8
	for i:=1; i < s; i++ {
		shift -= 6
		out[i] = char((r^ >> shift & 0xff | header) & 0xff)
	}

	return str(out)
}

fn getNextRune*(a: str, pos: int): Rune {
	c := int32(a[pos])

	// exit early if ascii character is detected
	if c & (1 << 8) == 0 {
		return Rune(c)
	}

	// find size of the rune
	size := 1
	for _:=0;
			pos + size < len(a) &&
			int(a[pos + size]) & (1 << 7 | 1 << 6) == 1 << 7;
			size++ { 
	
	}

	// generate mask for the first byte
	mask := 0
	for i:=0; i < size; i++ {
		mask |= 1 << i
	}

	sum := 0
	shift := (size - 1) * 6
	for i:=0; i < size && pos + i < len(a); i++ {
		sum |= ((int32(a[pos + i]) & 0xff) << shift)
		if i == 0 {
			mask = ~(1 << 7 | 1 << 6) // following bytes have 11000000 mask
		}
		shift -= 6
	}

	mask = 0
	for i:=0; i < (size - 1) * 6 + (8 - size - 1); i++ {
		mask |= 1 << i
	}

	return sum & mask
}

fn decode*(s: str): []Rune {
	runes := make([]Rune, len(s))
	runeCount := 0

	l := len(s)
	i := 0
	for i < l {
		runes[runeCount] = getNextRune(s, i)
		i += runes[runeCount].size()
		runeCount++
	}

	return slice(runes, 0, runeCount)
}

fn realLength*(s: str): int {
	rl := 0
	l := len(s)
	i := 0
	for i < l {
		r := getNextRune(s, i)
		i += r.size()
		rl++
	}

	return rl
}
